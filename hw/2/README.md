
**both part 2&3** FORTRAN(1950s), lisp(1950s), Algol 58(1950s), Cobol(1950s), Basic(1960s), C(1970s), sh(1970s), C++(1980s), FORTRAN 90 ISO/IEC(1990s), Java(1990s), Python(1990s), JavaScript(1990s), C#(2000s).  
2. ENIAC stands for (Electronic Numerical Integrator And Computer)
3. Any value that a computer can represent exactly is going to be based, eventually, on integers  
4. The fastest part of the computer memory is Cache memory.
5. The slowest storage device in computers is Disk.  
6. The smallest unit of information is A bit (Binary digit).  
7. (A) The closest programming languagae is Assembly Language.    
   (B) It does need an interpretation to become machine-comprehensible.    
8. (A) The oldest high-level programming language is FORTRAN.  
   (B) It was first released in 1956, so it is +69 years old and decade 1950s.    
9. (A) A second gen programming is Assembly language.  
   (B) Fortran, C, and C++ are all 3rd gen, and MATLAB, Python, and R are all in 4th gen.    
10. C(1970s) C++(1980s) MATLAB(1980s) Python(1990s).  
11. An ancestor programming language of C is B.  
12. An ancestor programming language of C++ is C, Simula.  
13. a programming language ancestor for MATLAB and Python are fortran and C.  
14. The fastest part of a memory is registers.  
15. The smallest memory unit is a bit(binary digit).  
16. RAM sits away from the processor (physically away). This makes data transfer to/from RAM slower.  
17. It is one to two orders of magnitude slower.  
18. RAM disk as compared to a Hard disk is typically up to 50 times faster for sequential reads and writes, and up to 200 times faster.  
19. The primary role of transistors are switches, letting current through to represent the binary digit 1, or cutting it off to represent 0.  
20. There is the physical footprint of the device. Increasing chip wize would mean we'd quickly have chips that are too big to fit in our devices.  
21. Three main stages: the fetch stage, the decode stage, and the execute stage.  
22. Yes it can since CPU can execute more cycles per second, leading to faster processing of tasks. However, it's not the only factor that affects overall performance; other elements like the number of cores, cache size, and the CPU's architecture also impact the speed of your computer.  
23. The RAM's inefficiency in processing and quickly transferring data to the CPU causes a memory bottleneck.  
24. Moore's Law makes gadgets more powerful by adding more switches, and Dennard Scaling keeps them energy-efficient by making them smaller and MOSFET is equivalent.  
25. **(1.)** 2080   **(2.)** 66,432     **(3.)** 9.47 pounds
26. **(1.)** 2^63 or 20,000,000,000,000,000,000  **(2.)** 2^64-1  **(3.)** 2.857142x10^15    **(4.)** 1500 years
27. The three fundamental components of a turning-complete language are infinite random access memory, conditional execution, and some form of repeated execution.
28. Exponential behavior has a tendency to show off rapid initial adjustments accompanied through saturation, while Power Law behavior demonstrates more slow modifications with a steady price across exclusive scales. Plotting on logarithmic scales can help become aware of those behaviors more absolutely.
